import scipy.cluster as sc
from io import StringIO
import numpy as np

class Cluster: 
    """
    Class that implements a clustering interface for CNV data. This class takes in a CNV data matrix generated by load_data.py and can calculate the clustering result of various agglomerative clustering strategies. The metric and method for determing linkage can be specified. Generated trees can be returned as Newick format, Bio.Phylo tree structures. Hierachical trees are cut to generate 4 clusters. 
    
    Attributes:
        self.trees (list): A list object containing all the trees 
        self.clust_ids (list):
        self.random_trees (list):
        self.random_clust_ids(list):
        self.available_methods (list):
        self.available_metrics (list):
        
    
    """
    def __init__(self): ## takes a CNVData matrix. 
        self.trees = []
        self.clust_ids=[]
        self.random_trees=[]
        self.random_clust_ids=[]
        self.available_methods = ['single','complete','average',
                                  'weighted','ward','median','centroid']
        
        self.available_metrics = ['braycurtis', 'canberra', 'chebyshev', 
                                  'cityblock', 'correlation', 'cosine', 'dice', 
                                  'euclidean', 'hamming', 'jaccard', 'jensenshannon', 
                                  'kulsinski', 'mahalanobis', 'matching', 'minkowski', 
                                  'rogerstanimoto', 'russellrao', 'seuclidean', 
                                  'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
        
    def cluster(self,data,method=None,metric=None,n_bootstraps=100):
        """   
        Function to cl

        """
        ## try to load the method. 
        if method:
            try:
                self.available_methods.index(method)
            except ValueError:
                raise Exception('Selected clustering method not available.')
        else:
            method = 'ward'
            
        
        ## try to load the metric
        if metric:
            try:
                self.available_metrics.index(metric)
            except ValueError:
                raise Exception('Selected clustering method not available.')
        else:
            metric = 'euclidean'
        
        
        rand = data.copy()
        num_zeroes = (data.values==0).sum()
        val_max = data.values.max()
 
        for x in range(0,n_bootstraps):
            
            boot_tree, boot_clust_id = self.cluster_single(data.sample(data.shape[1],replace=True,axis=1),method,metric)
            
            self.trees.append(boot_tree)
            self.clust_ids.append(boot_clust_id)
            
            rand_tree, rand_clust_id = self.cluster_single(self.generate_random(rand,val_max,num_zeroes),method,metric)
            
            self.random_trees.append(rand_tree)
            self.random_clust_ids.append(rand_clust_id)
                    
        return self.trees, self.random_trees, self.clust_ids, self.random_clust_ids

    def cluster_single(self,data,method,metric):
        link = sc.hierarchy.linkage(data,method,metric)
        tree = sc.hierarchy.to_tree(link)
        
        cluster_id = dict(zip(data.index,sc.hierarchy.cut_tree(link,n_clusters=4).T.tolist()[0]))
        
        cluster_newick = self.getNewick(tree, "", tree.dist, data.index)
        cluster_phylo = bp.read(StringIO(cluster_newick),'newick')
        return cluster_phylo, cluster_id

    
    def getNewick(self,node, newick, parentdist, leaf_names):
        """
        Function to 
        """
        if node.is_leaf():
            return "%s:%.2f%s" % (leaf_names[node.id], parentdist - node.dist, newick)
        else:
            if len(newick) > 0:
                newick = "):%.2f%s" % (parentdist - node.dist, newick)
            else:
                newick = ");"
            newick = self.getNewick(node.get_left(), newick, node.dist, leaf_names)
            newick = self.getNewick(node.get_right(), ",%s" % (newick), node.dist, leaf_names)
            newick = "(%s" % (newick)
            return newick
        
    def generate_random(self,rm,maxval,zeroes):
        randarray = np.random.random_sample(rm.values.size)*maxval
        randarray[np.random.choice(np.arange(0,rm.values.size-1),zeroes,replace=False)] = 0
        rm.iloc[:,:] = randarray.reshape(rm.shape)
        return(rm)