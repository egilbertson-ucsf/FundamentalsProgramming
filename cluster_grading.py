from sklearn import metrics
import numpy as np
import Bio.Phylo as bp
from scipy.optimize import linear_sum_assignment

def lookup_by_clades(tree):
    """
    Creates a dictionary of clades within a Bio.Phylo tree. The keys to the dictionary are
    the clade names, and the values the information contained within the Clade object having that
    clade name. Allows for easy searching by clade name.

    Input:
        tree (Bio.Phylo tree): Phylogenetic tree of interest
        
    Output:
        clades (dict): Dictionary with keys of clade names and value the content of the Clade object
        having that clade name.
    """
    clades = {}
    for clade in tree.find_clades():
        if clade.name:
            clades[clade.name] = clade
    return clades

def get_true_labels(species, tree):
    """
    When given a correct reptile phylogenetic tree, sorts each species into 1 of 4 clusters. Outputs a list
    corresponding of each species' correct cluster.

    Input:
        species(list): list of reptile species
        tree(Bio.Phylo tree): Correct reptile phylogenetic tree

    Output:
        labels(list): Ordered list consisting of integer values between 0 and 3. Each integer corresponds to
        a different cluster, and the list is indexed by reptile species.
    """
    labels = []
    clades = lookup_by_clades(tree)

    # There are 4 possible clusters, the 3 below and Squamata. The following creates a list of all species in
    # each of the clusters.
    crocodylia = [x.name for x in clades['Crocodylia'].get_terminals()]
    aves = [x.name for x in clades['Aves'].get_terminals()]
    testudines = [x.name for x in clades['Testudines'].get_terminals()]

    for name in species:
        name = name.replace('_', ' ')
        if name in crocodylia:
            labels.append(0)
        elif name in aves:
            labels.append(1)
        elif name in testudines:
            labels.append(2)
        else:
            labels.append(3)

    return labels

def get_pred_labels(species, tree, clust_id):
    """
    This function extracts an initial guess of predicted values from the clustered bootstrap output.

    Inputs:
        species(list): List of reptile species
        tree(Bio.Phylo tree): simulated tree
        clust_id(int): An integer between 0 and 3. Serves as an initial guess. Obtained from cutting simulated 
                       cluster.

    Outputs:
        labels(list): Ordered list consisting of integer values between 0 and 3. Each integer corresponds to a
        different cluster.
    """
    labels = []

    for name in species:
        label = clust_id[name]
        labels.append(label)

    return labels

def grade(species, trees, random_trees, true_tree):
    """
    This function first determines the ground truth class assignments
    and stores them in the list labels_true.

    Then, this function optimizes the initial guess of predicted clusters using minimum weight
    matching. The adjusted Rand index is then calculated using the true class assignments and
    the optimzed clustering algorithm assignments. The adjusted Rand index is a function that
    measures the similarity of the two assignments, normalized for random chance.

    The adjusted Rand index is then calculated using the true class
    assignments and the clustering algorithm assignments of the same
    samples as input. The adjusted Rand index is a function that measures
    the similarity of the two assignments, normalized for random chance, and is a float between -1 and 1.
    Negative values indicate less similarity than would be expected by random chance.

    Inputs:
    species (list): List of reptile species.
    trees (list): List of Bio.Phylo tree objects, simulated by the selected clustering algorithm
    random_trees (list): List of Bio.Phylo tree objects, with clusters generated by random assignment
    true_tree (tree): Bio.Phylo tree object corresponding to the true reptile phylogenetic tree.

    Outputs:
    ari_clusters (list): List of adjusted Rand indices, one for each of the bootstrap simulation.
    ari_random (list): List of adjusted Rand indices, one for each random simulation.
    
    """
    
    labels_true = get_true_labels(species, true_tree)
            
    ari_clusters = []
    ari_random = []

    i = 0
    for tree in trees:
        clust_id = clust_ids[i]
        labels_pred = get_pred_labels(species, tree, clust_id)
        test_array = np.zeros([4,4])
        for j in [0,3]:
            for k in [0,3]:
                test_array[j,k] = metrics.adjusted_rand_score(labels_true, [j if x==k else x for x in labels_pred])
        row_ind, col_ind = linear_sum_assignment(test_array)
        for j in row_ind:
            correct_value = col_ind[j]
            labels_pred = [correct_value if x==j else x for x in labels_pred]
        ari_cluster = metrics.adjusted_rand_score(labels_true, labels_pred)
                          
        i += 1
        ari_clusters.append(ari_cluster)
                
        
    i = 0
    for random_tree in random_trees:
        random_clust_id = random_clust_ids[i]
        labels_rand = get_pred_labels(species, random_tree, random_clust_id)
        test_array = np.zeros([4,4])
        for j in [0,3]:
            for k in [0,3]:
                test_array[j,k] = metrics.adjusted_rand_score(labels_true, [j if x==k else x for x in labels_rand])
        row_ind, col_ind = linear_sum_assignment(test_array)
        for j in row_ind:
            correct_value = col_ind[j]
            labels_rand = [correct_value if x==j else x for x in labels_rand]
        ari_rand = metrics.adjusted_rand_score(labels_true, labels_rand)
                                                                                                                        
        i += 1
        ari_random.append(ari_rand)


    return ari_clusters, ari_random

species_list = data.index
ari_clusters, ari_random = grade(species_list, trees, random_trees, true_tree)

        
